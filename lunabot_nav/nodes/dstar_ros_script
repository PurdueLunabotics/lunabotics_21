#!/usr/bin/env python3

import rospy
from geometry_msgs.msg import Twist, PoseStamped
from std_msgs.msg import Float32MultiArray
from nav_msgs.msg import Odometry, OccupancyGrid, Path
from map_msgs.msg import OccupancyGridUpdate
from tf.transformations import euler_from_quaternion, quaternion_from_euler
import dstar_ros
import numpy as np
import matplotlib.pyplot as plt

pose = []

map = []

goal = []

update_map = False

need_update_goal = False

res = 0

x_offset = 0

y_offset = 0

def grid_subscriber(data):
    global update_map, map, res, x_offset, y_offset
    width = data.info.width
    height = data.info.height
    map = np.reshape(data.data, (height, width))
    res = data.info.resolution
    x_offset = data.info.origin.position.x
    y_offset = data.info.origin.position.y
    update_map = True

def grid_update_subscriber(data):
    global update_map, map, res, x_offset, y_offset

    index = 0
    for i in range (data.y, data.y+data.height):
        for j in range (data.x, data.x+data.width):
            map[i][j] = data.data[index]
            index+=1

    update_map = True

def position_subscriber(data):
    global pose
    position = data.pose.pose.position

    coords = [position.x, position.y]
    pose = coords

def goal_subscriber(data):
    global goal, need_update_goal
    print("New Goal")
    goal = [data.pose.position.x, data.pose.position.y]
    need_update_goal = True

def main():
    global map, update_map, pose, goal, res, need_update_goal

    rospy.init_node('dstar_ros_script')

    radius = 8 #robot rad (grid units)

    frequency = 10 #hz

    dstar = None

    path_publisher = rospy.Publisher("/nav/global_path", Path, queue_size = 10)

    rospy.Subscriber("/maps/costmap_node/global_costmap/costmap", OccupancyGrid, grid_subscriber)

    rospy.Subscriber("/maps/costmap_node/global_costmap/costmap_updates", OccupancyGridUpdate, grid_update_subscriber)

    rospy.Subscriber("/odom", Odometry, position_subscriber)

    rospy.Subscriber("/goal", PoseStamped, goal_subscriber)

    rate = rospy.Rate(frequency)

    completedInitialRun = False

    path = []
    while not rospy.is_shutdown():
        if (dstar == None and len(map) > 0 and len(pose) > 0 and len(goal) > 0):
            dstar = dstar_ros.Dstar(goal, pose, map, radius, res, x_offset, y_offset)
            print("Initialize")

        if (dstar != None):
            # print("Iterate")

            dstar.update_position(pose)

            if (update_map):
                dstar.update_map(map, x_offset, y_offset)
                update_map = False

            if (need_update_goal):
                dstar = dstar_ros.Dstar(goal, pose, map, radius, res, x_offset, y_offset)
                print("created new Dstar")
                completedInitialRun = False
                # dstar.update_goal(goal)
                need_update_goal = False

            if (not completedInitialRun):
                dstar.find_path(True)
                completedInitialRun = True

            if (dstar.needs_new_path):
                path = np.array(dstar.createPathList())

                if (len(path) == 0):
                    print("publish empty path")
                else:
                    print("published path")

                temp = map.copy()
                ros_struct = Path()
                ros_struct.poses = []
                ros_struct.header.stamp = rospy.Time.now()
                ros_struct.header.frame_id = "odom"

                count = 0
                for index, point in enumerate(path):
                    path_pose = PoseStamped()

                    path_pose.pose.position.x = point[0]
                    path_pose.pose.position.y = point[1]

                    rotation = quaternion_from_euler(0,0,0)
                    path_pose.pose.orientation.x = rotation[0]
                    path_pose.pose.orientation.y = rotation[1]
                    path_pose.pose.orientation.z = rotation[2]
                    path_pose.pose.orientation.w = rotation[3]

                    if (count % 5 ==0 or np.all(path[index] == path[-1])):
                        ros_struct.poses.append(path_pose)
                    count+=1

                
                # plt.imshow(temp, cmap='hot', interpolation='nearest')
                # plt.show()
                path_publisher.publish(ros_struct)

        rate.sleep()

if __name__ == "__main__":
    main()