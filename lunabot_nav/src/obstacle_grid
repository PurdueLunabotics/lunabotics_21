#!/usr/bin/env python3
import numpy as np
import rospy

from tf.transformations import quaternion_from_euler, euler_from_quaternion 
from nav_msgs.msg import OccupancyGrid
from nav_msgs.msg import MapMetaData
from nav_msgs.msg import Odometry
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from geometry_msgs.msg import Quaternion

# Helper Functions to calculate the probabilities

""" Class that creates an Occupancy Grid that interfaces with devices to update probabilities and positions
 
Currently uses Lidar for detecting obstacles and T265 odometry to update position
"""


class ObstacleGrid:
    """ Instantiates an Occupancy Grid with specified parameters

    :param width: The width (amount of rows) in the occupancy grid
    :param height: The height (amount of columns) in the occupancy grid
    :param cell_size: The width and length of each cell in the occupancy grid
    :param p_prior: The default probability when a grid space is unknown
    :param p_occ: The probability needed to confidently say a space is occupied
    :param p_free: The probability needed to confidently say a space is free
    """

    def __init__(self, width, height, cell_size, p_prior=0.5, p_occ=0.75, p_free=0.45):
        # Node Initialization
        rospy.init_node("obstacle_grid")

        # Map Meta Data Initialization
        self.map_meta_deta = MapMetaData()
        self.map_meta_deta.width = width
        self.map_meta_deta.height = height
        self.map_meta_deta.resolution = cell_size

        self.width = width
        self.height = height
        self.cell_size = cell_size

        # Probability Initialization (use log odds to simplify math)
        self.p_prior = np.log(p_prior)
        self.p_occ = np.log(p_occ)
        self.p_free = np.log(p_free)

        # Grid Initialization
        self.grid = [[self.p_prior] * self.width] * self.height

        # Odometry Initialization
        self.odometry = Odometry()
        self.odometry.pose.pose.orientation = Quaternion()

        # Ros Publisher Initialization
        self.occupancy_grid_publisher = rospy.Publisher(
            "lunabot_nav/obstacle_grid", OccupancyGrid, queue_size=1
        )

        # Ros Subscriber Initialization
        rospy.Subscriber("/scan", LaserScan, self.update_occupancy_grid)
        rospy.Subscriber(
            "odom", Odometry, self.update_local_position
        )  # TODO use kalman filter instead of camera odometry

        rospy.Subscriber("cmd_vel", Twist, self.update_cmd_vel_ps)

        rospy.spin()

    """ Updates the occupancy grid based on lidar data and publishes the occupancy grid
    
    """

    def update_occupancy_grid(self, laser_scans):
        self.__inverse_sensor_model_lidar(laser_scans)
        self.publish_occupancy_grid()

    """ Updates known the local position of the robot for when the occupancy grid is updated

    """

    def update_local_position(self, odometry):
        self.odometry = odometry

    def update_cmd_vel_ps(self, twist):
        odometry = self.odometry
        odometry.pose.pose.position.x += twist.linear.x
        odometry.pose.pose.position.y += twist.linear.y
        odometry.pose.pose.position.z += twist.linear.z
        orientation = odometry.pose.pose.orientation
        angle = euler_from_quaternion(
            np.array([orientation.w, orientation.x, orientation.y, orientation.z])
        )
        angle[0] += twist.angular.x
        angle[1] += twist.angular.y
        angle[2] += twist.angular.z
        new_orientation = quaternion_from_euler(angle)
        orientation.w = new_orientation[0]
        orientation.x = new_orientation[1]
        orientation.y = new_orientation[2]
        orientation.z = new_orientation[3]
        odometry.pose.pose.orientation = orientation
        self.odometry = odometry

    """ Publishes occupancy grid data as a nav.msgs/OccupancyGrid message

    """

    def publish_occupancy_grid(self):
        occupancy_grid = OccupancyGrid()
        occupancy_grid.info = self.map_meta_deta
        data = []
        for row in self.grid:
            for val in row:
                prob = int(np.exp(val) * 100)
                # if(prob > 95):
                #     prob = 100
                # elif(prob < 5):
                #     prob = 0
                data.append(prob)
        occupancy_grid.data = data
        print(data)
        self.occupancy_grid_publisher.publish(occupancy_grid)

    """ Updates the occupancy grid using lidar data
    
    """

    def __inverse_sensor_model_lidar(
        self, laser_scans, min_angle=-3.14, max_angle=3.14, max_dist=20
    ):
        # Setup
        p_occ = self.p_occ
        p_free = self.p_free
        p_prior = self.p_prior
        angle = laser_scans.angle_min
        occupied_grid = [[0] * self.width] * self.height
        grid = self.grid
        odometry = self.odometry
        position = odometry.pose.pose.position
        cell_size = self.cell_size

        # Iterating through each scan
        for scan in laser_scans.ranges:

            # Checking to see if scan is in valid range
            if min_angle < angle < max_angle and scan < max_dist:
                # Calculating Detected Obstacle Position
                orientation = odometry.pose.pose.orientation
                robot_twist = euler_from_quaternion(
                    np.array(
                        [orientation.w, orientation.x, orientation.y, orientation.z]
                    )
                )
                global_twist = robot_twist[2] + angle
                global_twist *= np.pi / 180
                x_pos = position.x
                y_pos = position.y
                x_dir = np.cos(global_twist)
                y_dir = np.sin(global_twist)
                obstacle_location = self.__get_grid_location_from_coordinates(
                    x_pos + x_dir * scan, y_pos + y_dir * scan
                )
                if obstacle_location[0] != -1:
                    occupied_grid[obstacle_location[0]][obstacle_location[1]] = 2

                # Calculating empty squares in between obstacle
                current_square = self.__get_grid_location_from_coordinates(x_pos, y_pos)
                while (
                    not current_square[0] == obstacle_location[0]
                    or not current_square[1] == obstacle_location[1]
                ):
                    x_pos += (
                        x_dir * cell_size
                    )  # Moves at most 1 cell at a time, ensures all cells are accounted for
                    y_pos += y_dir * cell_size
                    current_square = self.__get_grid_location_from_coordinates(
                        x_pos, y_pos
                    )
                    if (
                        current_square != -1
                        and occupied_grid[current_square[0]][current_square[1]] == 0
                    ):
                        occupied_grid[current_square[0]][current_square[1]] = 1

            # Incrementing Angle
            angle += laser_scans.angle_increment
        # self.__print_grid()
        # Updating Occupancy Grid
        for i in range(len(grid)):
            for j in range(len(grid[i])):
                if occupied_grid[i][j] == 2:
                    grid[i][j] = grid[i][j] + p_occ - p_prior
                elif occupied_grid[i][j] == 1:
                    grid[i][j] = grid[i][j] + p_free - p_prior

    """ Converts real life (x, y) coordinates to grid coordinates
    
    :param x_coordinate: The real x coordinate of the location
    :param y_coordinate: The real y coordinate of the location
    :param x_0: The real x coordinate at the grid space [0, 0]
    :param y_0: The real y coordinate at the grid space [0, 0]
    """

    def __get_grid_location_from_coordinates(
        self, x_coordinate, y_coordinate, x_0=-1, y_0=-1
    ):
        x = int((x_coordinate - x_0) / self.cell_size)
        y = int((y_coordinate - y_0) / self.cell_size)
        if x < 0 or x >= self.width or y < 0 or y >= self.height:
            return [-1, -1]
        return [y, x]

    def __print_grid(self):
        for i in range(len(self.grid)):
            for j in range(len(self.grid[0])):
                print(str(self.grid[i][j]) + ", ", end=" ")
            print()
        for i in range(100):
            print()


# if __name__ == "main":
ObstacleGrid(320, 120, 0.1)