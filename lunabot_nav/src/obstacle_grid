#!/usr/bin/env python3
import math
import rospy
from nav.msgs import OccupancyGrid
from nav.msgs import MapMetaData
from nav.msgs import Odometry
from sensor_msgs.msg import LaserScan

""" Class that creates an Occupancy Grid that interfaces with devices to update probabilities and positions
 
Currently uses Lidar for detecting obstacles and T265 odometry to update position
"""


class ObstacleGrid:
    """ Instantiates an Occupancy Grid with specified parameters

    :param width: The width (amount of rows) in the occupancy grid
    :param height: The height (amount of columns) in the occupancy grid
    :param cell_size: The width and length of each cell in the occupancy grid
    :param p_prior: The default probability when a grid space is unknown
    :param p_occ: The probability needed to confidently say a space is occupied
    :param p_free: The probability needed to confidently say a space is free
    """

    def __init__(self, width, height, cell_size, p_prior=0.5, p_occ=1, p_free=0):
        # Node Initialization
        rospy.init()

        # Map Meta Data Initialization
        self.map_meta_deta = MapMetaData()
        self.map_meta_deta.width = width
        self.map_meta_deta.height = height
        self.map_meta_deta.resolution = cell_size

        self.cell_size = cell_size

        # Probability Initialization (use log odds to simplify math)
        self.p_prior = __probToLog(p_prior)
        self.p_occ = __probToLog(p_occ)
        self.p_free = __probToLog(p_free)

        # Grid Initialization
        self.grid = [[p_prior] * width] * height

        # Odometry Initialization
        self.odometry = Odometry()

        # Ros Publisher Initialization
        self.occupancy_grid_publisher = rospy.Publisher('lunabot_nav/obstacle_grid', OccupancyGrid, queue_size=1)

        # Ros Subscriber Initialization
        rospy.Subscriber('scan', LaserScan, self.update_occupancy_grid)
        rospy.Subscriber('t265/odom', Odometry,
                         self.update_local_position)  # TODO use kalman filter instead of camera odometry

    """ Updates the occupancy grid based on lidar data and publishes the occupancy grid
    
    """

    def update_occupancy_grid(self, laser_scans):
        self.__inverse_sensor_model_lidar(laser_scans)
        self.publish_occupancy_grid()

    """ Updates known the local position of the robot for when the occupancy grid is updated

    """

    def update_local_position(self, odometry):
        self.odometry = odometry

    """ Publishes occupancy grid data as a nav.msgs/OccupancyGrid message

    """

    def publish_occupancy_grid(self):
        occupancy_grid = OccupancyGrid()
        occupancy_grid.info = self.map_meta_deta
        data = []
        for row in self.grid:
            for val in row:
                data.append(int(__log_to_prob(val) * 100))
        occupancy_grid.data = data
        self.occupancy_grid_publisher.publish(occupancy_grid)

    """ Updates the occupancy grid using lidar data
    
    """

    def __inverse_sensor_model_lidar(self, laser_scans, min_angle=-3.14, max_angle=3.14, max_dist=10):
        # Setup
        p_occ = self.p_occ
        p_free = self.p_free
        p_prior = self.p_prior
        angle = laser_scans.angle_min
        occupied_grid = [[0] * width] * height
        grid = self.grid
        odometry = self.odometry
        position = odometry.pose.pose.position
        cell_size = self.cell_size

        # Iterating through each scan
        for scan in laser_scans.ranges:

            # Checking to see if scan is in valid range
            if min_angle < angle < max_angle and scan < max_dist:

                # Calculating Detected Obstacle Position
                robot_twist = __quat_to_euler(odometry.pose.pose.quaternion)
                global_twist = robot_twist + angle
                global_twist *= math.pi / 180
                x_pos = position.x
                y_pos = position.y
                x_dir = math.cos(global_twist)
                y_dir = math.sin(global_twist)
                obstacle_location = self.__get_grid_location_from_coordinates(x_pos + x_dir * scan,
                                                                              y_pos + y_dir * scan)
                occupied_grid[obstacle_location[0]][obstacle_location[1]] = 2

                # Calculating empty squares in between obstacle
                current_square = self.__get_grid_location_from_coordinates(x_pos, y_pos)
                while not current_square[0] == obstacle_location[0] or not current_square[1] == obstacle_location[1]:
                    x_pos += x_dir * cell_size  # Moves at most 1 cell at a time, ensures all cells are accounted for
                    y_pos += y_pos * cell_size
                    current_square = self.__get_grid_location_from_coordinates(x_pos, y_pos)
                    if occupied_grid[obstacle_location[0]][obstacle_location[1]] == 0:
                        occupied_grid[obstacle_location[0]][obstacle_location[1]] = 1

            # Incrementing Angle
            angle += laser_scans.angle_increment

        # Updating Occupancy Grid
        for i in range(len(grid)):
            for j in range(len(grid[i])):
                if occupied_grid[i][j] == 2:
                    grid[i][j] = grid[i][j] + p_occ - p_prior
                elif occupied_grid[i][j] == 1:
                    grid[i][j] = grid[i][j] - p_free - p_prior

    """ Converts real life (x, y) coordinates to grid coordinates
    
    :param x_coordinate: The real x coordinate of the location
    :param y_coordinate: The real y coordinate of the location
    :param x_0: The real x coordinate at the grid space [0, 0]
    :param y_0: The real y coordinate at the grid space [0, 0]
    """

    def __get_grid_location_from_coordinates(self, x_coordinate, y_coordinate, x_0=0, y_0=0):
        return [int((x_coordinate - x_0) / self.cell_size), int((y_coordinate - y_0) / self.cell_size)]


# Helper Functions to calculate the probabilities

""" Converts a probability value to log odds notation

:param value: The value to convert to log odds from pure probability
"""


def __prob_to_log(value):
    return math.log(value / (1 - value))


""" Converts a logg odds value to probability notation

:param value: The value to convert to probability from log odds
"""


def __log_to_prob(value):
    return 1 - 1 / (1 + math.pow(math.e, value))


""" Converts a quaternion to euler angles

:param quat: The quaternion to convert to euler angles
"""


def __quat_to_euler(quat):
    angles = {}
    sinr_cosp = 2 * (quat.w * quat.x + quat.y * quat.z)
    cosr_cosp = 1 - 2 * (quat.x * quat.x + quat.y * quat.y)
    angles['x'] = math.atan2(sinr_cosp, cosr_cosp)

    sinp = 2 * (quat.w * quat.y - quat.z * quat.x)
    if abs(sinp) > 1:
        angles['y'] = math.copysign(math.pi / 2, sinp)
    else:
        angles['y'] = math.asin(sinp)

    siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)
    cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)
    angles['z'] = math.atan2(siny_cosp, cosy_cosp)
    return angles
