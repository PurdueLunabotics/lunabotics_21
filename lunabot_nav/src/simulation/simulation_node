#!/usr/bin/env python3

import rospy
from rospy.client import get_param
from simulation import Simulation
from std_msgs.msg import Int32, Bool
from nav_msgs.msg import Odometry
from sensor_msgs.msg import LaserScan
from threading import Lock

class SimulationROS:
    def __init__(self, hz = 50):
        rospy.init_node('simulation_node')

        self.left_vel = 0
        self.right_vel = 0

        self.lock = Lock()

        self.simulation = Simulation(
            rospy.get_param('~robot_length', 4),
            rospy.get_param('~robot_width', 4),
            rospy.get_param('~field_width', 8),
            rospy.get_param('~field_height', 8),
            rospy.get_param('~pixels_per_meter', 50)
        )

        rospy.Subscriber('left_vel', Int32, self.update_left_vel) #TODO find correct topic to subscribe to
        rospy.Subscriber('right_vel', Int32, self.update_right_vel) #TODO find correct topic to subscribe to
        rospy.Subscriber('simulate', Bool, self.should_simulate)

        self.t265_publisher = rospy.Publisher('t265/odom', Odometry, queue_size=10)
        self.lidar_publisher = rospy.Publisher('/scan', LaserScan, queue_size=10)
        self.prev_time = rospy.Time.now().secs

        rate = rospy.Rate(hz)

        while not rospy.is_shutdown():
            self.update_simulation()
            print("WORKING")
            try:
                rate.sleep()
            except rospy.ROSInterruptException:
                pass

    def should_simulate(self, bool):
        if bool:
            self.simulation.start()
        else:
            self.simulation.stop()

    def update_simulation(self):
        self.lock.acquire()
        time = rospy.Time.now().secs
        self.simulation.update(self.left_vel, self.right_vel, time - self.prev_time)
        self.prev_time = time
        self.lock.release()
    
    def update_left_vel(self, vel):
        self.left_vel = vel.data

    def update_right_vel(self, vel):
        self.right_vel = vel.data

SimulationROS()