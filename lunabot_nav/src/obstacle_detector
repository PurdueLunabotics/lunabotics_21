#!/usr/bin/env python3
import rospy
from sensor_msgs.msg import LaserScan
from std_msgs.msg import Float64
from std_msgs.msg import Float64MultiArray

'''
Class to detect obstacles using the LIDAR
Note: Currently just returns ranges that obstacle is detected, will be changed to update mapping system when thats implemented
'''


def __make__Float64(value):
    float64 = Float64()
    float64.data = value
    return float64


class ObstacleDetector:

    def __init__(self):
        rospy.init_node('obstacle_detector')
        # Constants
        self.threshold = 10  # Maximum distance an obstacle can reasonably be at (if its too far of a measurement, probably detecting wall)
        self.angle_min = 1  # Minimum angle that lidar can scan for objects (since part of lidar scans will detect the robot)
        self.angle_max =  3 # Maximum angle that lidar can scan for objects

        # Ros Node Setup
        rospy.init_node('obstacle_detections')
        rospy.Subscriber('/scan', LaserScan, self.find_obstacle)
        self.obstacle_publisher = rospy.Publisher('lunabot_nav/obstacle_detector', Float64MultiArray, queue_size=1)
        rospy.spin()

    def find_obstacle(self, laser_scan):
        # Setup
        obstacles = []
        current_angle = laser_scan.angle_min
        has_obstacle = False
        start_angle = 0

        # Checking each angle for obstacles
        for laser_range in laser_scan.ranges:

            if self.angle_min <= current_angle <= self.angle_max:  # only bothers w/ calculations if inside desired range

                if laser_range < self.threshold and not has_obstacle:  # Finds start of obstacle
                    has_obstacle = True
                    start_angle = current_angle

                elif laser_range > self.threshold and has_obstacle:  # Finds end of obstacle, adds range to data
                    has_obstacle = False
                    obstacles.append(__make__Float64(start_angle))
                    obstacles.append(__make__Float64(current_angle))

            current_angle += laser_scan.angle_increment  # increments angle

        # Edge Case if obstacle starts in range but goes out of range
        if has_obstacle:
            obstacles.append(__make__Float64(start_angle))
            obstacles.append(__make__Float64(current_angle))

        # Publishing Data TODO: convert to updating general navigation mapping
        published_obsatacle = Float64MultiArray()
        published_obsatacle.data = obstacles
        self.obstacle_publisher.publish(published_obsatacle)

    # Converts float to Float64 object


if __name__ == "main":
    ObstacleDetector()
